#!/usr/bin/env python3
"""
Import reviewed translation spreadsheet into config/translations.yaml.

Reads the Final_PL and Final_DE columns from a reviewed Excel spreadsheet
(generated by generate_translation_spreadsheet.py) and updates the
translations.yaml configuration file.

Usage:
  poetry run python scripts/import_translation_spreadsheet.py reviewed.xlsx
  poetry run python scripts/import_translation_spreadsheet.py reviewed.xlsx --dry-run
  poetry run python scripts/import_translation_spreadsheet.py reviewed.xlsx --no-backup
  poetry run python scripts/import_translation_spreadsheet.py reviewed.xlsx --no-confirm
"""

import argparse
import re
import shutil
import sys
from datetime import datetime
from pathlib import Path

import openpyxl
import yaml


TRANSLATIONS_PATH = Path(__file__).parent.parent / "config" / "translations.yaml"


def read_spreadsheet(xlsx_path: str) -> tuple[dict, dict]:
    """Read Final_PL and Final_DE columns from the reviewed spreadsheet.

    Finds columns by header name so it works with both 9-column (old)
    and 11-column (new) layouts.

    Returns:
        Tuple of (final_pl dict, final_de dict) mapping key -> translation.
        Empty cells are skipped.
    """
    wb = openpyxl.load_workbook(xlsx_path, read_only=True)
    ws = wb['Translations']

    # Find column indices by header name
    headers = {}
    for col in range(1, ws.max_column + 1):
        val = ws.cell(row=1, column=col).value
        if val:
            headers[val] = col

    key_col = headers.get('Key')
    final_pl_col = headers.get('Final_PL')
    final_de_col = headers.get('Final_DE')

    if not key_col:
        print("ERROR: 'Key' column not found in spreadsheet.")
        sys.exit(1)

    final_pl = {}
    final_de = {}

    for row in range(2, ws.max_row + 1):
        key = ws.cell(row=row, column=key_col).value
        if not key:
            continue

        if final_pl_col:
            val = ws.cell(row=row, column=final_pl_col).value
            if val and str(val).strip():
                final_pl[key] = str(val).strip()

        if final_de_col:
            val = ws.cell(row=row, column=final_de_col).value
            if val and str(val).strip():
                final_de[key] = str(val).strip()

    wb.close()

    print(f"Read {len(final_pl)} Polish and {len(final_de)} German translations from spreadsheet.")
    return final_pl, final_de


def load_yaml_with_header(path: Path) -> tuple[str, dict]:
    """Load translations.yaml, separating comment header from data.

    Returns:
        Tuple of (header_comments string, parsed data dict).
    """
    text = path.read_text(encoding='utf-8')

    # Extract leading comment lines
    lines = text.split('\n')
    header_lines = []
    for line in lines:
        if line.startswith('#') or (line.strip() == '' and header_lines):
            header_lines.append(line)
        else:
            break

    # Stop collecting if we ended on blank lines — trim trailing blanks
    while header_lines and header_lines[-1].strip() == '':
        header_lines.pop()

    header = '\n'.join(header_lines)
    if header:
        header += '\n'

    data = yaml.safe_load(text)
    return header, data


def compute_diff(data: dict, new_values: dict, lang: str) -> list[dict]:
    """Compute differences between current YAML values and spreadsheet values.

    Returns list of change dicts with keys: key, type, old, new
    Types: NEW, PLACEHOLDER_REPLACED, CHANGED
    """
    current = data.get(lang, {})
    changes = []

    for key, new_val in new_values.items():
        old_val = current.get(key)

        if old_val is None:
            changes.append({'key': key, 'type': 'NEW', 'old': None, 'new': new_val})
        elif old_val == new_val:
            continue  # UNCHANGED
        elif re.match(r'^\[(?:PL|DE)\] ', str(old_val)):
            changes.append({'key': key, 'type': 'PLACEHOLDER_REPLACED', 'old': old_val, 'new': new_val})
        else:
            changes.append({'key': key, 'type': 'CHANGED', 'old': old_val, 'new': new_val})

    return changes


def print_diff(changes: list[dict], lang: str):
    """Display a readable diff of changes for a language."""
    if not changes:
        print(f"\n  {lang.upper()}: No changes.")
        return

    type_counts = {}
    for c in changes:
        type_counts[c['type']] = type_counts.get(c['type'], 0) + 1

    print(f"\n  {lang.upper()}: {len(changes)} changes "
          f"({', '.join(f'{v} {k.lower()}' for k, v in type_counts.items())})")
    print(f"  {'—' * 60}")

    for c in changes:
        tag = c['type']
        if tag == 'PLACEHOLDER_REPLACED':
            tag = 'PLACEHOLDER'
        print(f"  [{tag}] {c['key']}")
        if c['old'] is not None:
            print(f"    - {c['old']}")
        print(f"    + {c['new']}")


def apply_changes(data: dict, new_values: dict, lang: str, en_keys: list[str]):
    """Apply new translations to the data dict.

    Ensures keys are ordered to match the EN section order.
    """
    if lang not in data:
        data[lang] = {}

    # Update values
    for key, val in new_values.items():
        data[lang][key] = val

    # Reorder to match EN key order
    ordered = {}
    for key in en_keys:
        if key in data[lang]:
            ordered[key] = data[lang][key]
    # Append any keys not in EN (shouldn't happen, but safe)
    for key in data[lang]:
        if key not in ordered:
            ordered[key] = data[lang][key]

    data[lang] = ordered


def write_yaml_with_header(path: Path, header: str, data: dict):
    """Write translations.yaml with preserved comment header."""
    yaml_text = yaml.dump(data, default_flow_style=False, sort_keys=False,
                         allow_unicode=True, width=200)
    content = header + '\n' + yaml_text
    path.write_text(content, encoding='utf-8')


def main():
    parser = argparse.ArgumentParser(
        description="Import reviewed translation spreadsheet into translations.yaml"
    )
    parser.add_argument('spreadsheet', help='Path to the reviewed .xlsx file')
    parser.add_argument('--dry-run', action='store_true',
                       help='Show changes without applying them')
    parser.add_argument('--no-backup', action='store_true',
                       help='Skip creating a backup of translations.yaml')
    parser.add_argument('--no-confirm', action='store_true',
                       help='Skip confirmation prompt')
    args = parser.parse_args()

    xlsx_path = Path(args.spreadsheet)
    if not xlsx_path.exists():
        print(f"ERROR: File not found: {xlsx_path}")
        sys.exit(1)

    # 1. Read spreadsheet
    print(f"Reading spreadsheet: {xlsx_path}")
    final_pl, final_de = read_spreadsheet(str(xlsx_path))

    if not final_pl and not final_de:
        print("No translations found in spreadsheet. Nothing to do.")
        sys.exit(0)

    # 2. Load existing translations.yaml
    if not TRANSLATIONS_PATH.exists():
        print(f"ERROR: translations.yaml not found at {TRANSLATIONS_PATH}")
        sys.exit(1)

    header, data = load_yaml_with_header(TRANSLATIONS_PATH)
    en_keys = list(data.get('en', {}).keys())

    # 3. Compute and print diffs
    print("\nChanges to apply:")
    pl_changes = compute_diff(data, final_pl, 'pl') if final_pl else []
    de_changes = compute_diff(data, final_de, 'de') if final_de else []

    print_diff(pl_changes, 'pl')
    print_diff(de_changes, 'de')

    total_changes = len(pl_changes) + len(de_changes)
    if total_changes == 0:
        print("\nNo changes detected. translations.yaml is already up to date.")
        sys.exit(0)

    # 4. Dry run stops here
    if args.dry_run:
        print(f"\n[DRY RUN] {total_changes} changes would be applied. No files modified.")
        sys.exit(0)

    # 5. Confirmation
    if not args.no_confirm:
        response = input(f"\nApply {total_changes} changes to translations.yaml? [y/N] ")
        if response.lower() not in ('y', 'yes'):
            print("Aborted.")
            sys.exit(0)

    # 6. Backup
    if not args.no_backup:
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        backup_path = TRANSLATIONS_PATH.with_suffix(f'.yaml.bak.{timestamp}')
        shutil.copy2(TRANSLATIONS_PATH, backup_path)
        print(f"Backup saved: {backup_path}")

    # 7. Apply changes
    if final_pl:
        apply_changes(data, final_pl, 'pl', en_keys)
    if final_de:
        apply_changes(data, final_de, 'de', en_keys)

    write_yaml_with_header(TRANSLATIONS_PATH, header, data)
    print(f"\nUpdated {TRANSLATIONS_PATH}")

    # 8. Summary
    pl_placeholder = sum(1 for c in pl_changes if c['type'] == 'PLACEHOLDER_REPLACED')
    de_placeholder = sum(1 for c in de_changes if c['type'] == 'PLACEHOLDER_REPLACED')
    print(f"\nSummary:")
    print(f"  Polish: {len(pl_changes)} updates ({pl_placeholder} placeholders replaced)")
    print(f"  German: {len(de_changes)} updates ({de_placeholder} placeholders replaced)")
    print(f"  Total:  {total_changes} changes applied")


if __name__ == '__main__':
    main()
